通過Pygame Zero學習程式
==================================

萬丈高樓平地起.本教學面向任何零編程經驗人員.接下來我們會做一個簡單但非常有趣的遊戲.

我假設你安裝了Pygame Zero, 並且曉得如何使用文本編輯器.

新建一個空白文件
----------------

首先,通過你的編輯器新建一個名為 "fishfrenzy.py" 的空白文件並把 "fishfrenzy.py" 
保存到新的目錄.

通過運行下面的命令確認空白文件運行並且創建了空白窗口::

    cd the_directory_you_created
    pgzrun fishfrenzy.py

\如何運行取決於你的編輯器,shell或者你載入的其他插件.

如果運行失敗,有可能是因為你的文件路徑錯了, Python或者Pygame Zero沒有正確安裝,以及各種
千奇百怪的原因.從某種意義上講,第一步是最難邁出的,但是這已經超過了這篇教學的範圍,取決於
很多不同配置,比如你的操作系統, 你python的版本,你Pygame的版本等等.

如果你的代碼運行那你的運氣可真不錯!如果你看到一個空白的 "Pygame Zero Game" 創客,我們就
就可以進行下一步了.

真的是運氣嗎?
-------------

你可以在下面的聊天室獲得幫助,或者添加微信ilangxm, 備註pygame zero我會拉你入群

http://webchat.freenode.net?randomnick=1&channels=##learnpython&uio=d4

函數
----------

讓我們正式開始吧.

對大部分大部分程式語言來,編程就是定義一系列計算機可以執行的步驟,就像是 **菜譜**. 在烹飪
裡,你可能有下列菜譜:

    **蛋糕菜譜**

    * 碗裡家店面
    * 碗裡加點糖
    * 碗裡加點奶油
    * 碗裡加一個雞蛋
    * 快速攪拌
    * 把碗裡的東東導入蛋糕模子
    * 烘烤

... 等等,當然按照這個菜譜大概是做不出蛋糕的,因為我不是廚師啊

程式設計人員中的遊戲就是如何把這些看做一個程序,並且在一個能夠理解你定義的任意指令的
虛擬計算機中運行.這叫做 **虛擬碼** 因為看起來像代碼,但實際上不能運行.如果我們把菜譜
翻譯成Python程序,就會像這樣::

    def cake_recipe():
        bowl.add(flour)
        bowl.add(sugar)
        bowl.add(butter)
        bowl.add(egg)
        whisk(bowl)
        cake_tin.add(bowl.get_contents())
        bake(cake_tin)

虛擬碼和Python代碼很相似.雖然我們用一些特殊的方式拼寫單字,但總體上Python和虛擬碼的每一
行都是等價的 - 都是一個 "動作" 或者說 "行為" .

第一行中的 ``def`` 定義了一個叫做 ``cake_recipe`` 的菜譜, 其他代碼是菜譜的步驟.都用
parentheses,表示他們只想計算機可能知道的其他菜譜.

讓我們用Pygame Zero寫一個真正的食譜. 在你的編輯器裡,讓我們寫一個 ``draw`` 食譜.Pygame
可以正確的調用名為 ``draw`` 的函數::


    def draw():
        screen.clear()

        screen.draw.circle((400, 300), 30, (255, 255, 255))

用一下命令運行::

    pgzrun fishfrenzy.py

你的代碼運行了嗎? 看到一個圓圈沒?我的電腦看起來是:

.. image:: _static/grabs/circle.png

如果Pygame Zero沒有創建窗口,或者出現了一個窗口然後閃退, 看一下出現的錯誤提示:

* ``SyntaxError`` - 語法錯誤,意味著你可能漏掉了一個括號,或者縮進跟我的代碼有區別.注意
  函數的每一行必須對齊, 但是必須比頂部的 ``def`` 縮進 **多一些**
* ``AttributeError`` or ``NameError`` - 屬性或者名稱錯誤, 你可能有拼寫錯誤.
* ``TypeError`` - 類型錯誤,是不是有的括號位置錯了?

如果窗口出現了,但是窗口什麼都不顯示,檢查一下 "draw" 是不是拼錯了? 或者數字有沒有寫錯?

如果代碼一開始就不能運行,仔細檢查一下你的代碼,多嘗試幾次代碼就能正常運行了.

我們定義了一個包含兩個步驟的食譜:

1. 清空螢幕,讓螢幕顯示黑色
2. 在螢幕上畫個圈圈:

    * ``(400, 300)`` 是圓心坐標, 用距離螢幕左上角的坐標數表示.
    * 半徑是 ``30`` 像素
    * 圓的輪廓是白色的,用三人數表示, 分別表示紅綠藍
      的值 ``(255, 255, 255)``. 白色是紅,綠和藍的混合色. ``255`` 是顏色的最大值.

你可以 **嘗試改變這三個值**,運行程序並查看效果.


進階:本地和全局變數
-------------------------------------

建設我們寫了如下代碼::

    RED = 150, 0, 0
    GREEN = 0, 128, 0

    bg = RED

    def draw():
        screen.fill(bg)

    def on_mouse_down():
        bg = GREEN

    def on_mouse_up():
        bg = RED

有的語言中,這樣寫沒有問題的: 當單擊螢幕的時候螢幕是綠色,鬆開滑鼠按鈕,螢幕變成紅色.

但是在Python中是不行的.如果你試著運行這段代碼,你就會發現螢幕不會變成綠色.為什麼捏?

當你在函數內部像第10行一樣用 ``==`` 進行賦值操作的時候, 你就新建了一個僅僅在函數內部
存在的bg變數. 我們想修改的 ``bg`` 是全局變數, 這實際上是一個非常明智的做法,你不想...

解決辦法是在 ``on_mouse_down`` 和 ``on_mouse_up`` 函數中明確的表示我們是想修改全局
變數,而不是新建一個本地變數. 我們用 ``global`` 聲明來完成這個目標. 正確的Pygame Zero
代碼如下::

    RED = 150, 0, 0
    GREEN = 0, 128, 0

    bg = RED

    def draw():
        screen.fill(bg)

    def on_mouse_down():
        global bg
        bg = GREEN

    def on_mouse_up():
        global bg
        bg = RED
網易少兒編程郎郎老師翻譯, 微信 ilangxm
